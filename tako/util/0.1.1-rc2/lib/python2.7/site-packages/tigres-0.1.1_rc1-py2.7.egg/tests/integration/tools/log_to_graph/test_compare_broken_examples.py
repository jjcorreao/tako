"""
7/2/14 by James Fox
"""

import os
import subprocess
import unittest
import glob
from tests.integration.tools.log_to_graph.resources.broken_workflows.basic_broken import *

"""
Tests require graphviz installed
"""
DOT_EXEC_CMD = "python {} EXECUTION_LOCAL_THREAD"
LOG_TO_DOT_CMD = "python {} graph {} -o {}"

class Test(unittest.TestCase):
    files_to_remove = [] # intermediate files to remove (each test is responsible for adding files to this list)
    resources_path = ""
    outs_path = ""
    workflows_path = ""
    this_file_dir = ""
    log_to_graph_path = ""

    """ Sets up paths """
    @classmethod
    def setUpClass(self):
        file_dir_name = os.path.dirname(os.path.realpath(__file__))
        Test.this_file_dir = file_dir_name
        Test.resources_path = os.path.join(file_dir_name, 'resources')
        Test.outs_path = os.path.join(file_dir_name, '.')
        Test.workflows_path = os.path.join(file_dir_name, 'resources/broken_workflows')
        Test.log_to_graph_path = os.path.join(file_dir_name, '../../../..', 'tigres/core/tools/log.py')

    @classmethod
    def tearDownClass(self):
        """ Remove intermediate files """
        for file in Test.files_to_remove:
            os.remove(file)

    def generate_dot_outputs(self, intmd_reg_dot_file, final_reg_dot_file, log_file, intmd_log_dot_file, final_log_dot_file, addt_pyfile_args=None):
        ref_dot_str = ""
        log_dot_str = ""
        intmd_reg_dot = os.path.join(os.path.realpath(os.curdir), intmd_reg_dot_file)
        results = subprocess.Popen(["nop", intmd_reg_dot], stdout=subprocess.PIPE)
        final_ref_dot_path = os.path.join(Test.outs_path, final_reg_dot_file)
        ref_dot_str += readFromAndWriteTo(results, final_ref_dot_path)
        log_file = os.path.join(Test.workflows_path, log_file)
        subprocess.call(LOG_TO_DOT_CMD.format(Test.log_to_graph_path, log_file, Test.this_file_dir).split(" "))
        intmd_log_dot = os.path.join(Test.this_file_dir, intmd_log_dot_file)
        results2 = subprocess.Popen(["nop", intmd_log_dot], stdout=subprocess.PIPE)
        final_log_dot_path = os.path.join(Test.outs_path, final_log_dot_file)
        log_dot_str += readFromAndWriteTo(results2, final_log_dot_path)

        # mark unnecessary files for removal
        if intmd_reg_dot not in Test.files_to_remove:
            Test.files_to_remove.append(intmd_reg_dot)
        if intmd_log_dot not in Test.files_to_remove:
            Test.files_to_remove.append(intmd_log_dot)
        if log_file not in Test.files_to_remove:
            Test.files_to_remove.append(log_file)
        if final_log_dot_path not in Test.files_to_remove:
            Test.files_to_remove.append(final_log_dot_path)
        if final_ref_dot_path not in Test.files_to_remove:
            Test.files_to_remove.append(final_ref_dot_path)
        return ref_dot_str, log_dot_str

    def test_broken_sequence(self):
        print("testing broken sequence!\n")
        runBrokenSequence()
        ref_dot_str, log_dot_str = Test.generate_dot_outputs(self, "BrokenSequence.dot", "broken_sequence.dot", \
            "basic_broken.log", 'basic_broken_graph.dot', "broken_sequence_test.dot")
        self.assertEqual(ref_dot_str, log_dot_str)

    def test_single_broken_parallel(self):
        print("testing single broken parallel!\n")
        runSingleBrokenParallel()
        ref_dot_str, log_dot_str = Test.generate_dot_outputs(self, "BrokenParallel.dot", "broken_parallel.dot", \
            "basic_broken.log", 'basic_broken_graph.dot', "broken_parallel_test.dot")
        self.assertEqual(ref_dot_str, log_dot_str)

    def test_multiple_broken_parallel(self):
        print("testing split and merge!\n")
        runMultipleBrokenParallel()
        ref_dot_str, log_dot_str = Test.generate_dot_outputs(self, "MultipleBrokenParallel.dot", "multiple_broken_parallel.dot", \
            "basic_broken.log", 'basic_broken_graph.dot', "multiple_broken_parallel_test.dot")
        self.assertEqual(ref_dot_str, log_dot_str)

    def test_broken_after_split(self):
        print("testing broken after split!\n")
        runBrokenAfterSplit()
        ref_dot_str, log_dot_str = Test.generate_dot_outputs(self, "BrokenAfterSplit.dot", "broken_after_split.dot", \
            "basic_broken.log", 'basic_broken_graph.dot', "broken_after_split_test.dot")
        self.assertEqual(ref_dot_str, log_dot_str)

    def test_broken_split_task(self):
        print("testing broken split task!\n")
        runBrokenSplitTask()
        ref_dot_str, log_dot_str = Test.generate_dot_outputs(self, "BrokenSplitTask.dot", "broken_split_task.dot", \
            "basic_broken.log", 'basic_broken_graph.dot', "broken_split_task_test.dot")
        self.assertEqual(ref_dot_str, log_dot_str)

    def test_broken_merge_task(self):
        print("testing broken merge task!\n")
        runBrokenMergeTask()
        ref_dot_str, log_dot_str = Test.generate_dot_outputs(self, "BrokenMergeTask.dot", "broken_merge_task.dot", \
            "basic_broken.log", 'basic_broken_graph.dot', "broken_merge_task_test.dot")
        self.assertEqual(ref_dot_str, log_dot_str)

""" Returns (relative) path to specified file name """
def getFilePath(file_name):
    return glob.glob(file_name)[0]

def readFromAndWriteTo(readSrc, outFilePath):
        s = ""
        with open(outFilePath, 'wb') as output_file:
                while True:
                    line = readSrc.stdout.readline()
                    if not line:
                        break
                    s += bytes.decode(line, 'UTF-8')
                    output_file.write(line)
                output_file.close()
        return s

if __name__ == "__main__":
    print(os.path.dirname(__file__))




