import sys
from tigres import *

# Initial inputs to the workflow
from tigres.utils import Execution


input1_task1 = 'hello'



# Following functions are given 
def task1impl(text):
    return text


def task2impl(text):
    return text[::-1]


def main(execution):
    # This example tests implicit depenendence in sequence
    start(name="example_workflow_function_implicit", log_dest='example_workflow_function_implicit.log',
          execution=execution)

    # Define input types for Task1
    task1_types = InputTypes("Task1types", [str])
    # Define Task 1
    task1 = Task("Task1", FUNCTION, task1impl, task1_types, None)
    # Assign inputs for task1
    task1_values = InputValues("Input Task1", [input1_task1])

    # Similarly, define input types and task for task2
    task2_types = InputTypes("Task2types", [str])
    task2 = Task("Task2", FUNCTION, task2impl, task2_types, None)

    # Testing to see if implicit dependency is respected

    # task2_values = InputValues("Input Task2", [PREVIOUS])

    # Create a task array containing task1 and task2
    task_array12 = TaskArray("sequence tasks12", [task1, task2])

    # Create a data array with task1 and task2's input values

    # NOTE: We need to consider an input array with just one element might mean only first task has inputs

    input_array12 = InputArray("sequence data12", [task1_values])

    # Invoke the template
    output_seq = sequence("my seq", task_array12, input_array12)

    print("Sequence Output: \n")
    print(output_seq)

    dot_execution()


if __name__ == "__main__":

    if len(sys.argv) <= 1:
        print(("Usage: {} ({})>".format(sys.argv[0], "|".join(list(Execution.LOOKUP.keys())))))
        exit()
    main(Execution.get(sys.argv[1]))