"""
Test the following:
- Find activities with errors
- Track back from an error through its parent/sibling activities
"""
import tigres
from tigres.utils import State
from tigres.core.monitoring import log

__author__ = 'Dan Gunter <dkgunter@lbl.gov>'
__date__ = '7/8/13'

#
import argparse
import time
import types
#
from tigres import *


def do_nothing(sec=0.1):
    print(("-- Sleeping for {}".format(sec)))
    time.sleep(sec)


def do_error(value=1, user_error=True):
    if user_error:
        print("-- dividing by zero..")
        x = value / 0


# Syntax helpers

def ftask(fn):
    return Task(None, FUNCTION, fn)


def ftasks(fnlist):
    return TaskArray(None, list(map(ftask, fnlist)))


def sapply(functions=(), inputs=(), name=None):
    """Simplified syntax for sequence template.
    """
    inputs = InputArray(None, inputs)
    if isinstance(functions, types.FunctionType):
        functions = [functions]
    if len(functions) == len(inputs):
        tasks = TaskArray(None, list(map(ftask, functions)))
    elif len(functions) == 1:
        fn = functions[0]
        tasks = [Task(None, FUNCTION, fn) for _ in inputs]
    else:
        raise ValueError("Number of functions must be 1 or "
                         "the same as the number of inputs ({ni:d}), got {nf:d}"
        .format(ni=len(inputs), nf=len(functions)))
    return sequence(name, tasks, inputs)


def papply(functions=(), inputs=(), name=None):
    """Simplified syntax for parallel template.
    """
    inputs = InputArray(None, inputs)
    if isinstance(functions, types.FunctionType):
        functions = [functions]
    tasks = TaskArray(None, list(map(ftask, functions)))
    return parallel(name, tasks, inputs)

# Main class


class Stages:
    N = 10

    def __init__(self):
        self.seq_num, self.p_num = 0, 0

    def run(self, stage):
        print(("** Running stage '{}'".format(stage)))
        tigres.debug(State.paste("stage", State.RUN), stage=stage)
        if stage == 'S':
            self.seq_num += 1
            self._run_sequence(do_nothing)
        elif stage == 'P':
            self.p_num += 1
            self._run_parallel(do_nothing)
        else:
            tigres.debug("error_time")
            print("** ERROR time")
            self.p_num += 1
            self._run_parallel(do_error)
        print(("** Done with stage {}".format(stage)))
        tigres.debug(State.paste("stage", State.DONE), stage=stage)

    def _run_sequence(self, func):
        name = "Seq{}".format(self.seq_num)
        return sapply(func, [[0.1]] * self.N, name=name)

    def _run_parallel(self, func):
        name = "Parallel{}".format(self.p_num)
        return papply(func, [[0.1]] * self.N, name=name)


class StageError(Exception):
    def __init__(self, msg, stage, status):
        message = "Stage {}: {}. Status: {}".format(stage, msg, status)
        Exception.__init__(self, message)


class OutputError(Exception):
    def __init__(self, looking, found):
        message = "Looking for {}, found {}".format(looking, found)
        Exception.__init__(self, message)


def run():
    logfile = "/tmp/error-context-{:.3f}".format(time.time())
    Program(log_dest=logfile)
    log.set_level(tigres.DEBUG)
    stages = Stages()
    for stage in 'S', 'P', 'E', 'S':
        stages.run(stage)
        status = log.check('any', None)[0]
        if status.errcode != 0:
            raise StageError("Unexpected non-zero error code", stage, status)
        if stage == 'E':
            status = log.check('task', None)[0]
            if status.errcode == 0:
                raise StageError("Unexpected zero error code for error task", stage, status)
                # Get all records from the template that failed
            template_info = log.find(None, template_id=status.template_id)
            # .. look for various messages
            lookfor = {'error_time': 1, # set to expected count,
                       'failure': Stages.N}     # decrement to zero in loop below
            for rec in template_info:
                if rec.tg_name == 'error_time':
                    print("## Found user error message")
                    lookfor['error_time'] -= 1
                if rec.tg_ntype == log.NodeType.TASK and rec.tg_state == log.State.DONE \
                    and rec.state != 0:
                    print("## Found failure")
                    lookfor['failure'] -= 1
                # .. report errors (non-zero counts)
            for item, count in list(lookfor.items()):
                if count > 0:
                    raise OutputError(item, "nothing")
                elif count < 0:
                    raise OutputError(item, "too many ({:d})".format(count))


def main(cmdline=None):
    parser = argparse.ArgumentParser()
    if cmdline is None:
        args = parser.parse_args()
    else:
        args = parser.parse_args(cmdline)
    run()


if __name__ == '__main__':
    main()
