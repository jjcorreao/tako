try:
    xrange
    range = xrange
except NameError:
    pass
import os
import pickle
import shutil
import unittest
import sys

from mock import patch, MagicMock

import tigres
from tigres.utils import State, Execution


count_runs = 0
if sys.version_info[0] < 3:
    BUILTIN = '__builtin__'
else:
    BUILTIN = 'builtins'


def do_something_else(a):
    return a - 1


def do_something(a):
    return do_something_else(a * a)


class TestCaseExecutionJobManagerPlugins(unittest.TestCase):
    def setUp(self):
        """
        Set up the test environment. Create working directory
        """

        self._execution_sge = tigres.core.execution.load_plugin(Execution.SGE)
        self._execution_slurm = tigres.core.execution.load_plugin(Execution.SLURM)
        self._cwd = os.path.split(__file__)[0]
        self._cwd_sge = self._cwd + "/output-sge"

        if os.path.exists(self._cwd_sge):
            shutil.rmtree(self._cwd_sge)
        os.mkdir(self._cwd_sge)
        os.chdir(self._cwd_sge)
        global count_runs
        count_runs = 0

    def tearDown(self):
        """Remove generated files and state directory"""
        os.chdir(self._cwd)
        shutil.rmtree(self._cwd_sge)

    def test_write_job_script(self):
        """
        Make sure that the job script is written correctly
        """

        self._execution_sge.write_job_script("echo", "My Very Own SGE Task")

        assert os.path.exists(self._cwd_sge + "/MyVeryOwnSGETask.sh")

        self._execution_slurm.write_job_script("echo", "My Very Own SLURM Task")

        assert os.path.exists(self._cwd_sge + "/MyVeryOwnSLURMTask.sh")

    def test_write_function_script(self):
        """
        Make sure that the job script is written correctly
        """

        function_script_filename = self._execution_sge.write_function_script("My Very Own SGE Task", do_something,
                                                                             [10])

        assert os.path.exists(function_script_filename)

        output = None
        with open(function_script_filename, 'rb') as f:
            output = f.read()

        #print ("'"+output+"'")

        assert output == b"""# -*- coding: utf-8 -*-
import pickle
fn = pickle.load(open('./MyVeryOwnSGETask.code','rb'))
args = pickle.loads(pickle.load(open('./MyVeryOwnSGETask.args','rb')))
try:
    result = fn(*args)
    pickle.dump(result, open('./MyVeryOwnSGETask.result','wb'))
except Exception as e:
    result = None
    pickle.dump(result, open('./MyVeryOwnSGETask.result','wb'))
    raise e"""

        exec (output)

        os.path.exists('MyVeryOwnSGETask.result')

        with open('MyVeryOwnSGETask.result', 'rb') as f:
            output = f.read()

        val = pickle.loads(output)
        assert val == 99

    def test_get_job_script(self):
        """ Make sure that the job script contents are correct"""

        job_script = self._execution_sge._get_job_script(command="echo", name="foobar")

        assert """#!/bin/bash
#$ -cwd
#$ -S /bin/bash
#$ -j y	         # Combine stderr and stdout
#$ -o $JOB_NAME.$JOB_ID.out        # Name of the output file
#$ -V

echo 2>foobar.err 1>foobar.out
""" == job_script

        job_script = self._execution_slurm._get_job_script(command="echo", name="foobar")

        assert """#!/bin/bash
#
#SBATCH --output=foobar.%J.out

## Run command
echo 2>foobar.err 1>foobar.out
""" == job_script

    def test_submit_job(self):
        """ Validates the job submission semantics
        """

        with patch('tigres.core.execution.plugin.job.run_command') as mock_run_command:
            self.assertIs(tigres.core.execution.plugin.job.run_command, mock_run_command)

            mock_run_command.return_value = "job submitted 1"

            job_id = self._execution_sge._submit_job("foo")

            mock_run_command.assert_called_once_with("qsub -N foo ./foo.sh ", env=None)

            assert job_id == "1"

            mock_run_command.reset_mock()
            mock_run_command.return_value = "Submitted batch job 136"

            job_id = self._execution_slurm._submit_job("foo")

            mock_run_command.assert_called_once_with("sbatch -J foo ./foo.sh ", env=None)

            assert job_id == "136"

    def test_is_job_finished(self):
        """ Make sure that the job finished logic and semantics are correct when a job is finished """

        with patch('tigres.core.execution.plugin.job.getstatusoutput') as mock_commands:
            self.assertIs(tigres.core.execution.plugin.job.getstatusoutput, mock_commands)

            mock_commands.return_value = (0, "")
            is_finished = self._execution_sge._is_job_finished("1", "foo")

            mock_commands.assert_called_with("qstat | grep foo | grep 1")

            assert is_finished is True

            mock_commands.reset_mock()
            mock_commands.return_value = (0, "")
            is_finished = self._execution_slurm._is_job_finished("136", "foo")

            mock_commands.assert_called_once_with("squeue -j 136 | grep -v JOBID")

            assert is_finished is True

    def test_is_not_job_finished(self):
        """ Make sure that the job finished logic and semantics are correct when a job is NOT finished """

        with patch('tigres.core.execution.plugin.job.getstatusoutput') as mock_commands:
            self.assertIs(tigres.core.execution.plugin.job.getstatusoutput, mock_commands)

            # Sun Grid Engine
            mock_commands.return_value = (0, "")
            is_finished = self._execution_sge._is_job_finished("2", "bar")
            mock_commands.assert_called_with("qstat | grep bar | grep 2")
            assert mock_commands.call_count == 2
            assert is_finished is True

            # SLURM
            mock_commands.reset_mock()
            mock_commands.return_value = (
                0, "    123     batch      foo      vch   R       0:13      1 n0000")
            is_finished = self._execution_slurm._is_job_finished("123", "foo")
            mock_commands.assert_called_once_with("squeue -j 123 | grep -v JOBID")
            assert is_finished is False

    def test_get_job_output(self):
        """
        Test that the job output is returned correctly
        """
        from mock import mock_open

        m = mock_open(read_data="""fooooooooo
fooooooooo
fooooooooo
fooooooooo
fooooooooo""")

        patcher = patch('{}.open'.format(BUILTIN), m)
        mock_open = patcher.start()

        self.assertIs(open, mock_open)
        value = self._execution_sge._get_job_output("1", "foo bar")
        assert value[1] == """fooooooooo
fooooooooo
fooooooooo
fooooooooo
fooooooooo"""

        self.assertIs(open, mock_open)
        value = self._execution_slurm._get_job_output("1", "foo bar")

        assert value[0] == """fooooooooo
fooooooooo
fooooooooo
fooooooooo
fooooooooo"""
        assert value[1] == """fooooooooo
fooooooooo
fooooooooo
fooooooooo
fooooooooo"""

        patcher.stop()

    def test_get_job_no_output(self):
        """
        Test that the job output is returned correctly
        """
        from mock import mock_open

        m = mock_open(read_data='')

        patcher = patch('{}.open'.format(BUILTIN), m)
        mock_open = patcher.start()

        self.assertIs(open, mock_open)
        value1, value2 = self._execution_sge._get_job_output("1", "foo bar")
        assert value1 == ''
        assert value2 == ''

        #this one will error because scontrol is not on this system.
        value1, value2 = self._execution_slurm._get_job_output("1", "foo bar")
        assert value1 == ''
        assert value2 == ''

        patcher.stop()

    def test_parallel(self):
        """
        Tests that parallel job are run correctly
        """

        def run_fn(work):
            global count_runs
            work.do_nothing()
            print(count_runs)
            if count_runs >= 5:
                work.state = State.DONE
                work.results = [1, 2, 3]
                print(('DONE', work.name, work.results))

            else:
                print('NOT DONE')
                work.state = State.RUN
                count_runs += 1

        parallel_work = []
        for i in range(300):
            parallel_work.append(MagicMock())
            parallel_work[i].name = str(i)
            parallel_work[i].method.do_nothing.return_value = MagicMock(return_value=True)

        self._execution_sge.parallel(parallel_work, run_fn)
        for i in range(300):
            assert parallel_work[i].results == [1, 2, 3]

    def test_execute_executable_not_finished(self):
        """
        Test what happens when job is submitted but not finished
        """

        with patch('tigres.core.execution.plugin.job.create_executable_command') as mock_command:
            with patch('tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._submit_job') as mock_submit:
                with patch(
                        'tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._is_job_finished') as mock_finished:
                    task = MagicMock()
                    task.unique_name = "Foo Bar"
                    input_values = [x for x in range(10)]
                    execution_data = {'env': {}}
                    mock_command.return_value = "foo"
                    mock_submit.return_value = "1"
                    mock_finished.return_value = False
                    results = self._execution_sge.execute_executable("foo bar", task, input_values, execution_data)
                    mock_submit.assert_called_once_with('foobar')
                    assert results[1] is State.RUN
                    assert results[0] is None
                    assert execution_data == {'job_id': '1', 'job_script_name': 'foobar', 'env': {}}

    def test_execute_executable_finished(self):
        """
        Test what happens when job is submitted and finishes
        """

        with patch('tigres.core.execution.plugin.job.create_executable_command') as mock_command:
            with patch('tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._submit_job') as mock_submit:
                with patch(
                        'tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._is_job_finished') as mock_finished:
                    with patch(
                            'tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._get_job_output') as mock_output:
                        task = MagicMock()
                        task.unique_name = "Foo Bar"
                        input_values = [x for x in range(10)]
                        execution_data = {'env': {}}
                        mock_command.return_value = "foo"
                        mock_submit.return_value = "1"
                        mock_finished.return_value = True
                        mock_output.return_value = (None, "Output")
                        results = self._execution_sge.execute_executable("foo bar", task, input_values, execution_data)
                        mock_submit.assert_called_once_with('foobar')
                        assert results[1] is State.DONE
                        assert results[0] == "Output"
                        assert execution_data == {'job_id': '1', 'job_script_name': 'foobar', 'env': {}}

    def test_execute_executable_finished_error(self):
        """
        Test what happens when job is submitted and finishes
        """

        with patch('tigres.core.execution.plugin.job.create_executable_command') as mock_command:
            with patch('tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._submit_job') as mock_submit:
                with patch(
                        'tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._is_job_finished') as mock_finished:
                    with patch(
                            'tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._get_job_output') as mock_output:
                        task = MagicMock()
                        task.unique_name = "Foo Bar"
                        input_values = [x for x in range(10)]
                        execution_data = {'env': {}}
                        mock_command.return_value = "foo"
                        mock_submit.return_value = "1"
                        mock_finished.return_value = True
                        mock_output.return_value = ("There has been an error", "")
                        self.assertRaises(tigres.utils.TigresException,
                                          self._execution_sge.execute_executable, "foo bar", task,
                                          input_values, execution_data)


    def test_execute_executable_check_only(self):
        """
        Test what happens when job has already been submitted (should not be submitted more than once
        """

        with patch('tigres.core.execution.plugin.job.create_executable_command') as mock_command:
            with patch('tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._submit_job') as mock_submit:
                with patch(
                        'tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._is_job_finished') as mock_finished:
                    with patch(
                            'tigres.core.execution.plugin.job.ExecutionPluginJobManagerSGE._get_job_output') as mock_output:
                        task = MagicMock()
                        task.unique_name = "Foo Bar"
                        input_values = [x for x in range(10)]
                        execution_data = {'job_id': '1', 'job_script_name': 'FooBar'}
                        mock_command.return_value = "foo"
                        mock_submit.return_value = "1"
                        mock_finished.return_value = True
                        mock_output.return_value = (None, "Output")
                        results = self._execution_sge.execute_executable("foobar", task, input_values, execution_data)
                        assert mock_submit.call_count == 0
                        assert results[1] is State.DONE
                        assert results[0] == "Output"


if __name__ == '__main__':
    unittest.main()
