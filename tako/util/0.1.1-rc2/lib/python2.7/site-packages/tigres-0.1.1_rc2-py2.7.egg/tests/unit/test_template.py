"""
Template class tests
"""
try:
    xrange
    range = xrange
except NameError:
    pass
from tigres.utils import Execution, TigresException

__author__ = 'dang'

# Stdlib
import unittest
# Local
from tigres import Task, InputValues, FUNCTION, TaskArray, InputArray, sequence, parallel, merge, PREVIOUS, split, \
    start, end, get_results, log_info, \
    query, Keyword, check


def one_arg(a):
    return a


def abide(*args):
    log_info(("Abiding -> {}".format(" ".join([str(a) for a in args]))))
    return args


def split_fn(*iterable):
    result = [e for e in iterable]
    return result


def stir(arglist):
    return ['+'.join(map(str, args))
            for args in arglist]


def split_pairs(data):
    result = []
    if len(data) == 0:
        return [result]
    for i in range(0, len(data) - 1, 2):
        result.append([data[i], data[i + 1]])
    if len(data) % 2 == 1:
        result.append([data[-1], None])
    return result


def merge_pairs(data):
    result = []
    for pair in data:
        for p in pair:
            result.append(p)
    return result


class TestCommon(unittest.TestCase):
    """Put module-shared functions here.
    """

    def setUp(self):
        start(name="TestRunPRocess", execution=Execution.LOCAL_THREAD)
        self._inputs = [[10.3, 'pounds'], [30, 'feet'], [18.4, 'mph']]
        t1 = Task("grab_ball", FUNCTION, abide)
        i1 = InputValues("weight", self._inputs[0])

        t2 = Task("aim_at_pins", FUNCTION, abide)
        i2 = InputValues("distance", self._inputs[1])

        t3 = Task("roll_ball", FUNCTION, abide)
        i3 = InputValues("speed", self._inputs[2])

        self.task_array = TaskArray("bowling", [t1, t2, t3])
        self.input_array = InputArray("quantities", [i1, i2, i3])
        self._tasks = [t1, t2, t3]
        self._inputs = [i1, i2, i3]

    def tearDown(self):
        " Remove generated log files "
        import os
        import glob

        end()

        for logfile in glob.glob("tigres*.log"):
            os.unlink(logfile)


class TestRunProcess(TestCommon):
    def test_sequence(self):
        "sequence template"
        output = sequence("dude", task_array=self.task_array,
                          input_array=self.input_array)
        latest = get_results()
        self.assertEqual(latest, output)
        self.assertEqual(output, tuple(self._inputs[-1]))


    def test_parallel(self):
        "data parallel template"
        output = parallel("dude", task_array=self.task_array,
                          input_array=self.input_array)

        latest = get_results()
        self.assertEqual(latest, output)

        for i in range(len(self._inputs)):
            outp = tuple(self._inputs[i])  # since func. just returns inputs
            self.assert_(outp in output, "values {} not found in outputs".format(outp))



    def test_split(self):
        ## need to understand the implicit PREVIOUS
        "split template"
        split_input = InputValues("split", ['one', 'two', 'three'])
        splitter = Task("seven_ten", FUNCTION, split_fn)
        output = split("dude", task_array=self.task_array,
                       input_array=[[PREVIOUS]], split_task=splitter,
                       split_input_values=split_input)
        latest = get_results()
        self.assertEqual(latest, output)

        print(("split template output = {}".format(output)))
        for i in range(len(split_input)):
            outp = tuple(abide([split_input])[0])
            self.assert_(outp in output, "values {} not found in outputs".format(outp))

    def test_split_no_inputs(self):

        def distributeCandy():
            CANDY = ['twix', 'snickers', 'hershey']
            return CANDY

        def consumeCandy(c):
            return "The {} was delicious!".format(c)

        split_task = Task("Hand out candy", FUNCTION, impl_name=distributeCandy, input_types=[])
        split_input = InputValues(None, [])
        after_split_tasks = TaskArray("Candy for everyone")
        after_split_tasks.append(Task("Eat candy", FUNCTION, impl_name=consumeCandy, input_types=[str]))
        previous_inputs = InputArray("String Values", [])
        output = split('Give and eat candy', split_task, split_input, after_split_tasks, previous_inputs)
        self.assertEqual(['The twix was delicious!', 'The snickers was delicious!', 'The hershey was delicious!'], output)

    def test_parallel_no_inputs(self):

        def random_number_generator():
            from random import randint
            return randint(1, 100)

        task_array = TaskArray("Random Numbers")
        tasks = [ Task("A Number {}".format(i), FUNCTION, impl_name=random_number_generator, input_types=[]) for i in range(10)]
        task_array.extend(tasks)
        input_array = InputArray("String Values", [[] for _ in range(10)])
        output = parallel('Parallel Tasks with no inputs', task_array, input_array)
        self.assertEqual(10, len(output))

    def test_sequence_no_inputs(self):

        def random_number_generator():
            from random import randint
            return randint(1, 100)

        task_array = TaskArray("Random Numbers")
        tasks = [ Task("A Number {}".format(i), FUNCTION, impl_name=random_number_generator, input_types=[]) for i in range(10)]
        task_array.extend(tasks)
        input_array = InputArray("String Values", [[] for _ in range(10)])
        output = sequence('Sequence Tasks with no inputs', task_array, input_array)
        assert 1 <= output <= 100

    def test_merge_no_inputs(self):

        def random_number_generator():
            from random import randint
            return [randint(1, 100), randint(1, 100)]

        "merge template"
        merger = Task("seven_ten", FUNCTION, stir, input_types=[str])
        task_array = TaskArray("Random Numbers")
        tasks = [Task("A Number {}".format(i), FUNCTION, impl_name=random_number_generator, input_types=[]) for i in range(10)]
        task_array.extend(tasks)

        output = merge("dude", task_array=task_array,
                       input_array=[[] for _ in range(10)],
                       merge_task=merger)
        self.assertEqual(10, len(output))

        records = query(["level >= 40", "event = DONE"], fields=[Keyword.NAME, Keyword.TASK_UID
            , Keyword.PROGRAM_UID, Keyword.TMPL_UID, Keyword.STATE])

    def test_merge(self):
        "merge template"
        merger = Task("seven_ten", FUNCTION, stir, input_types=[str])
        output = merge("dude", task_array=self.task_array,
                       input_array=self.input_array,
                       merge_task=merger)
        latest = get_results()
        self.assertEqual(latest, output)

        print(("merge template output = {}".format(output)))
        for i in range(len(self._inputs)):
            outp = stir([[10.3, 'pounds'], [30, 'feet'], [18.4, 'mph']])[0]
            print(outp)
            self.assert_(outp in output, "values {} not found in outputs".format(outp))

        records = query(["level >= 40", "event = DONE"],
                        fields=[Keyword.NAME, Keyword.TASK_UID, Keyword.WORK_UID, Keyword.MESSAGE,
                                Keyword.NODETYPE,
                                Keyword.PROGRAM_UID, Keyword.TMPL_UID, Keyword.STATE])

        assert (records)
        for r in records:
            assert(Keyword.EVENT in r)
            assert(Keyword.NODETYPE in r)
            assert(Keyword.NAME in r)
            assert(Keyword.PROGRAM_UID in r)
            assert(Keyword.STATE in r)
            assert(r[Keyword.LEVEL] >= 40)
            assert(r.event == "DONE")


class TestRunImplied(TestCommon):
    """
    Testing for implied inputs and tasks
    """

    def test_sequence_within_template_implied_previous(self):
        "run sequence template with implied inputs from the PREVIOUS sequence task"
        for t in self.task_array:
            t._impl_name = one_arg
        ia = InputArray("quantities", [[10]])
        output = sequence("dude", task_array=self.task_array,
                          input_array=ia)
        self.assertEqual(output, 10)

    def test_sequence_within_template_explicit_previous(self):
        "run sequence template with explicit PREVIOUS"

        def one_arg(a):
            return a

        for t in self.task_array:
            t._impl_name = one_arg
        ia = InputArray("quantities", [[10], [PREVIOUS], [PREVIOUS]])
        output = sequence("dude", task_array=self.task_array,
                          input_array=ia)
        print(output)
        self.assertEqual(output, 10)

    def test_sequence_prev3(self):
        # I think we need to understand more of the syntax before we can
        # determin wheter this is a valid test.
        "run sequence template with PREVIOUS for 1 input"
        i3 = [PREVIOUS.i[0],  # first is from previous
              self._inputs[2][1]]  # second is from third input
        ia = InputArray("quantities", [self._inputs[0], self._inputs[1], i3])
        output = sequence("dude", task_array=self.task_array,
                          input_array=ia)
        expected = (self._inputs[1][0],  # first is from previous
                    i3[1])  # second is from third input
        self.assertEqual(output, expected)

    def test_sequence_between_templates_previous(self):
        "run 2 sequence templates with PREVIOUS between them"

        def one_arg(a):
            return a

        for t in self.task_array:
            t._impl_name = one_arg
        output1 = sequence("dude", task_array=self.task_array,
                           input_array=[[11], [22], [33]])
        ia = InputArray("p", [[PREVIOUS], [PREVIOUS], [PREVIOUS]])
        output2 = sequence("dude", task_array=self.task_array,
                           input_array=ia)
        self.assertEqual(output1, output2)

    def test_named_sequence_prev(self):
        "named task previous within a sequence"
        ivals = self._inputs  # start with fixed inputs
        ivals[2][0] = PREVIOUS.grab_ball.i[0][0]  # point at 1st output
        ia = InputArray("quantities", ivals)
        output = sequence("dude", task_array=self.task_array,
                          input_array=ia)
        # now, 1st item in third and final output should be the same as 1st
        self.assertEqual(output[0], self._inputs[0][0])

    def test_var_sequence_prev(self):
        """variable task previous within a sequence"""
        get_that_ball = self._tasks[0]  # create local variable for 1st task
        ivals = self._inputs  # start with fixed inputs
        ivals[2][0] = PREVIOUS.get_that_ball.i[0]  # point at 1st output
        ia = InputArray("quantities", ivals)
        output = sequence("dude", task_array=self.task_array,
                          input_array=ia)
        # now, 1st item in third and final output should be the same as 1st
        print(output)
        self.assertEqual(output, (10.3, 'mph'))

    def test_double_sequence_prev(self):
        # I think we need to understand more of the syntax before we can
        # determin wheter this is a valid test.
        "combine var and name task PREVIOUS"
        get_that_ball = self._tasks[0]  # create local variable for 1st task
        ivals = self._inputs
        ivals[1][0] = PREVIOUS.get_that_ball.i[0]
        ivals[1][1] = PREVIOUS.grab_ball.i[1]
        ivals[2] = [PREVIOUS]
        ia = InputArray("quantities", ivals)
        output = sequence("dude", task_array=self.task_array, input_array=ia)
        # now, we should have copied inputs down
        self.assertEqual(output[0], tuple(self._inputs[0]))

    def test_errs1(self):
        "error handling 1"
        ivals = self._inputs  # start with fixed inputs
        ivals[2][0] = PREVIOUS.grab_nachos.i[0]  # point at NOTHING
        ia = InputArray("quantities", ivals)
        with self.assertRaises(IndexError):
            sequence("dude", task_array=self.task_array,
                     input_array=ia)

    def test_errs2(self):
        "error handling 2"
        ivals = self._inputs  # start with fixed inputs
        ivals[1][0] = PREVIOUS.i[3]  # out of range
        ia = InputArray("quantities", ivals)
        with self.assertRaises(IndexError):
            sequence("dude", task_array=self.task_array,
                     input_array=ia)


class TestRunPreviousParallel(TestCommon):
    def test_parallel(self):
        "data parallel"
        pass


if __name__ == '__main__':
    unittest.main()
