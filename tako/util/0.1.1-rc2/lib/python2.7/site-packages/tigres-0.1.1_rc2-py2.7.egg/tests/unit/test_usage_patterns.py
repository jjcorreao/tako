"""
Stretching use of unittest framework to test for the following usage patterns

Function only executables.

seq_single
seq_multi
seq_multi_dep
seq_multi_dep_implicit
par_uniform
par_single_task
par_single_input
split_standalone
split_previous
split_previous_implicit
split_after_seq
split_before_split
split_single_task
split_single_input
test_merge_standalone
test_merge_previous
test_merge_previous_plus
test_merge_previous_implicit
test_merge_single_task
test_merge_single_input


created on 2013-04-30 by Gilberto Pastorello <gzpastorello@lbl.gov>
"""
import glob
import os
import unittest

from tigres import Task, TaskArray, InputTypes, InputValues, InputArray, FUNCTION, PREVIOUS, end, start
from tigres import sequence, parallel, split, merge

# Mock user functions


def f_add(par): return par + 1


def f_add2(par1, par2): return par1 + par2


def f_mult(par1, par2): return par1 * par2


def f_pow(par1, par2): return par1 ** par2


def f_add_l(l1, l2=None):
    if not l2: l2 = []
    return sum(l1) + sum(l2)

# Module setup for all test cases
def setUpModule():
    start()
    # timestamp = datetime.now()
    # log_name = '/tmp/usage_patterns_tests_{}.log'.format(timestamp.strftime('%Y-%m-%dT%H-%M-%S.%f') )
    # dot_full_name = '/tmp/usage_patterns_tests_{}_full.dot'.format(timestamp.strftime('%Y-%m-%dT%H-%M-%S.%f') )
    # dot_exec_name = '/tmp/usage_patterns_tests_{}_exec.dot'.format(timestamp.strftime('%Y-%m-%dT%H-%M-%S.%f') )
    # dot_data_name = '/tmp/usage_patterns_tests_{}_data.dot'.format(timestamp.strftime('%Y-%m-%dT%H-%M-%S.%f') )
    # tigres.init("usage_patterns", log_name,
    #             dot_full_filename=dot_full_name,
    #             dot_exec_filename=dot_exec_name,
    #             dot_data_filename=dot_data_name,
    #             dot_data_include_nodep=False)
    pass


def tearDownModule():
    end()
    for logfile in glob.glob("tigres*.log"):
        os.unlink(logfile)


class TestUsagePatterns(unittest.TestCase):
    def test_seq_single(self):
        """
            Single task workflow using Tigres sequence construct
        """

        # Define input types for Task
        task_types = InputTypes("Single Task Types", [int])
        # Define inputs for Task
        task_values = InputValues("Single Task Values", [1])
        # Define Task
        task = Task("Single Task", FUNCTION, f_add, task_types, None)

        # Create a task array containing Task
        task_array = TaskArray("Sequence TaskArray", [task, ])

        # Create an input array to feed to Task
        input_array = InputArray("Sequence InputArray", [task_values])

        # Invoke the template
        output = sequence("Sequence Single Task", task_array, input_array)

        self.assertEqual(2, output)


    def test_seq_multi(self):
        """
            Multiple independent tasks workflow using Tigres sequence construct
        """

        # setup Task 1: input types, input values, task
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [1])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, input values, task
        task2_types = InputTypes("Task2 Types", [int, int])
        task2_values = InputValues("Task2 Input", [2, 3])
        task2 = Task("Task2", FUNCTION, f_add2, task2_types, None)

        # setup Task 3: input types, input values, task
        task3_types = InputTypes("Task3 Types", [int, int])
        task3_values = InputValues("Task3 Input", [4, 5])
        task3 = Task("Task3", FUNCTION, f_add2, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Sequence TaskArray", [task1, task2, task3])
        input_array = InputArray("Sequence InputArray", [task1_values, task2_values, task3_values])

        # Invoke the template
        output = sequence("Sequence Multiple Tasks", task_array, input_array)

        self.assertEqual(9, output)


    def test_seq_multi_dep(self):
        """
            Multiple dependent tasks workflow using Tigres sequence construct
        """

        # setup Task 1: input types, input values, task
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [1])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, input values, task
        task2_types = InputTypes("Task2 Types", [int])
        task2_values = InputValues("Task2 Input", [PREVIOUS])
        task2 = Task("Task2", FUNCTION, f_add, task2_types, None)

        # setup Task 3: input types, input values, task
        task3_types = InputTypes("Task3 Types", [int, int])
        task3_values = InputValues("Task3 Input", [PREVIOUS, 2])
        task3 = Task("Task3", FUNCTION, f_add2, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Sequence TaskArray", [task1, task2, task3])
        input_array = InputArray("Sequence InputArray", [task1_values, task2_values, task3_values])

        # Invoke the template
        output = sequence("Sequence Multiple Dependent Tasks", task_array, input_array)

        self.assertEqual(5, output)


    def test_seq_multi_dep_implicit(self):
        """
            Multiple implicitly dependent tasks workflow using Tigres sequence construct
        """

        # setup Task 1: input types, input values, task
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [1])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, input values, task
        task2_types = InputTypes("Task2 Types", [int])
        task2 = Task("Task2", FUNCTION, f_add, task2_types, None)

        # setup Task 3: input types, input values, task
        task3_types = InputTypes("Task3 Types", [int])
        task3 = Task("Task3", FUNCTION, f_add, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Sequence TaskArray", [task1, task2, task3])
        input_array = InputArray("Sequence InputArray", [task1_values])

        # Invoke the template
        output = sequence("Sequence Multiple Dependent Tasks Implicit", task_array, input_array)
        self.assertEqual(4, output)


    def test_par_uniform(self):
        """
            Equal number of tasks and inputs in parallel
        """
        # setup Task 1: input types, input values, task
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [1])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, input values, task
        task2_types = InputTypes("Task2 Types", [int])
        task2_values = InputValues("Task2 Input", [2])
        task2 = Task("Task2", FUNCTION, f_add, task2_types, None)

        # setup Task 3: input types, input values, task
        task3_types = InputTypes("Task3Types", [int, int])
        task3_values = InputValues("Task3 Input", [3, 4])
        task3 = Task("Task3", FUNCTION, f_add2, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Parallel TaskArray", [task1, task2, task3])
        input_array = InputArray("Parallel InputArray", [task1_values, task2_values, task3_values])

        output = parallel("Parallel Uniform", task_array, input_array)

        self.assertEqual([2, 3, 7], output)


    def test_par_single_task(self):
        """
            Single task and multiple inputs in parallel (replicate task)
        """
        # setup Task 1: input values
        task1_values = InputValues("Task1 Input", [1])

        # setup Task 2: input values
        task2_values = InputValues("Task2 Input", [2])

        # setup Task 3: input values
        task3_values = InputValues("Task3 Input", [3])

        # setup Task: input types, task
        task_types = InputTypes("TaskTypes", [int])
        task = Task("Task", FUNCTION, f_add, task_types, None)

        # Create task and input arrays for Task
        task_array = TaskArray("Parallel TaskArray", [task])
        input_array = InputArray("Parallel InputArray", [task1_values, task2_values, task3_values])

        # Invoke the template
        output = parallel("Parallel Single Task", task_array, input_array)

        self.assertEqual([2, 3, 4], output)


    def test_par_single_input(self):
        """
            Multiple tasks and single input in parallel (replicate input)
        """

        # setup Task 1: input types, task
        task1_types = InputTypes("Task1 Types", [int, int])
        task1 = Task("Task1", FUNCTION, f_add2, task1_types, None)

        # setup Task 2: input types, task
        task2_types = InputTypes("Task2 Types", [int, int])
        task2 = Task("Task2", FUNCTION, f_mult, task2_types, None)

        # setup Task 3: input types, task
        task3_types = InputTypes("Task3 Types", [int, int])
        task3 = Task("Task3", FUNCTION, f_pow, task3_types, None)

        tasks_input = InputValues("Input", [2, 3])

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Parallel TaskArray", [task1, task2, task3])
        input_array = InputArray("Parallel InputArray", [tasks_input])

        # Invoke the template
        output = parallel("Parallel Single Input", task_array, input_array)

        self.assertEqual([5, 6, 8], output)


    def test_split_standalone(self):
        """
            Tests split only workflow
        """

        # setup first task
        first_types = InputTypes("First Task Types", [int])
        first_task_values = InputValues("First Task Input", [1])
        first_task = Task("First Task", FUNCTION, f_add, first_types, None)

        # setup Task 1: input types, input values, task
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [1])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, input values, task
        task2_types = InputTypes("Task2 Types", [int])
        task2_values = InputValues("Task2 Input", [2])
        task2 = Task("Task2", FUNCTION, f_add, task2_types, None)

        # setup Task 3: input types, input values, task
        task3_types = InputTypes("Task3Types", [int])
        task3_values = InputValues("Task3 Input", [3])
        task3 = Task("Task3", FUNCTION, f_add, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Split TaskArray", [task1, task2, task3])
        input_array = InputArray("Split InputArray", [task1_values, task2_values, task3_values])

        output_list = split("Split Standalone", first_task, first_task_values, task_array, input_array)

        self.assertEqual([2, 3, 4], output_list)


    def test_split_previous(self):
        """
            Tests split only workflow using PREVIOUS in arguments
        """

        # setup first task
        first_types = InputTypes("First Task Types", [int])
        first_task_values = InputValues("First Task Input", [1])
        first_task = Task("First Task", FUNCTION, f_add, first_types, None)

        # setup Task 1: input types, input values, task
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [PREVIOUS])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, input values, task
        task2_types = InputTypes("Task2 Types", [int, int])
        task2_values = InputValues("Task2 Input", [PREVIOUS, 2])
        task2 = Task("Task2", FUNCTION, f_add2, task2_types, None)

        # setup Task 3: input types, input values, task
        task3_types = InputTypes("Task3Types", [int, int])
        task3_values = InputValues("Task3 Input", [PREVIOUS, 3])
        task3 = Task("Task3", FUNCTION, f_mult, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Split TaskArray", [task1, task2, task3])
        input_array = InputArray("Split InputArray", [task1_values, task2_values, task3_values])

        output_list = split("Split Previous", first_task, first_task_values, task_array, input_array)

        self.assertEqual([3, 4, 6], output_list)


    def test_split_single_task(self):
        """
            Tests split with multiple inputs and single task for parallel part
        """

        # setup first task
        first_types = InputTypes("First Task Types", [int])
        first_task_values = InputValues("First Task Input", [1])
        first_task = Task("First Task", FUNCTION, f_add, first_types, None)

        # setup Task 1: input values
        task1_values = InputValues("Task1 Input", [PREVIOUS])

        # setup Task 2: input values
        task2_values = InputValues("Task2 Input", [PREVIOUS])

        # setup Task 3: input values
        task3_values = InputValues("Task3 Input", [PREVIOUS])

        # setup Task: input types, task
        task_types = InputTypes("TaskTypes", [int])
        task = Task("Task", FUNCTION, f_add, task_types, None)

        # Create task and input arrays for Task
        task_array = TaskArray("Split TaskArray", [task])
        input_array = InputArray("Split InputArray", [task1_values, task2_values, task3_values])

        # Invoke the template
        output_list = split("Split Single Task", first_task, first_task_values, task_array, input_array)
        #print output_list
        self.assertEqual([3, 3, 3], output_list)


    def test_split_single_input(self):
        """
            Tests split with single input and multiple tasks for parallel part
        """

        # setup first task
        first_types = InputTypes("First Task Types", [int])
        first_task_values = InputValues("First Task Input", [1])
        first_task = Task("First Task", FUNCTION, f_add, first_types, None)

        # setup Task 1: input types, task
        task1_types = InputTypes("Task1 Types", [int, int])
        task1 = Task("Task1", FUNCTION, f_add2, task1_types, None)

        # setup Task 2: input types, task
        task2_types = InputTypes("Task2 Types", [int, int])
        task2 = Task("Task2", FUNCTION, f_mult, task2_types, None)

        # setup Task 3: input types, task
        task3_types = InputTypes("Task3 Types", [int, int])
        task3 = Task("Task3", FUNCTION, f_pow, task3_types, None)

        tasks_input = InputValues("Input", [PREVIOUS, 3])

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Split TaskArray", [task1, task2, task3])
        input_array = InputArray("Split InputArray", [tasks_input])

        # Invoke the template
        output_list = split("Split Single Input", first_task, first_task_values, task_array, input_array)

        self.assertEqual([5, 6, 8], output_list)


    def test_split_after_seq(self):
        """
            Tests split right after sequence
        """
        # setup/invoke/test sequence
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [1])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        task2_types = InputTypes("Task2 Types", [int, int])
        task2_values = InputValues("Task2 Input", [2, 3])
        task2 = Task("Task2", FUNCTION, f_add2, task2_types, None)

        task_array_seq = TaskArray("Sequence TaskArray", [task1, task2])
        input_array_seq = InputArray("Sequence InputArray", [task1_values, task2_values])

        output = sequence("Sequence-Split Seq", task_array_seq, input_array_seq)

        self.assertEqual(5, output)

        # setup/invoke/test split
        first_types = InputTypes("First Task Types", [int, int])
        first_task_values = InputValues("First Task Input", [PREVIOUS.task1, PREVIOUS.task2])
        first_task = Task("First Task", FUNCTION, f_add2, first_types, None)

        task3_types = InputTypes("TaskTypes", [int])
        task3_values = InputValues("Task3 Input", [PREVIOUS])
        task3 = Task("Task", FUNCTION, f_add, task3_types, None)
        task4_types = InputTypes("TaskTypes", [int])
        task4_values = InputValues("Task4 Input", [PREVIOUS])
        task4 = Task("Task", FUNCTION, f_add, task4_types, None)
        task5_types = InputTypes("TaskTypes", [int])
        task5_values = InputValues("Task5 Input", [PREVIOUS])
        task5 = Task("Task", FUNCTION, f_add, task5_types, None)

        task_array_split = TaskArray("Split TaskArray", [task3, task4, task5])
        input_array_split = InputArray("Split InputArray", [task3_values, task4_values, task5_values])

        output_list = split("Sequence-Split Split", first_task, first_task_values, task_array_split, input_array_split)

        self.assertEqual([8, 8, 8], output_list)

    def test_split_before_seq(self):
        """
            Tests split followed by sequence after one of the tasks
        """
        # setup/invoke/test split
        first_types = InputTypes("First Task Types", [int, int])
        first_task_values = InputValues("First Task Input", [1])
        first_task = Task("First Task", FUNCTION, f_add, first_types, None)

        task1_types = InputTypes("TaskTypes", [int])
        task1_values = InputValues("Task1 Input", [PREVIOUS])
        task1 = Task("Task", FUNCTION, f_add, task1_types, None)
        task2_types = InputTypes("TaskTypes", [int])
        task2_values = InputValues("Task2 Input", [PREVIOUS])
        task2 = Task("Task", FUNCTION, f_add, task2_types, None)
        task3_types = InputTypes("TaskTypes", [int])
        task3_values = InputValues("Task3 Input", [PREVIOUS])
        task3 = Task("Task", FUNCTION, f_add, task3_types, None)

        task_array_split = TaskArray("Split TaskArray", [task1, task2, task3])
        input_array_split = InputArray("Split InputArray", [task1_values, task2_values, task3_values])

        output_list = split("Sequence-Split Split", first_task, first_task_values, task_array_split, input_array_split)

        self.assertEqual([3, 3, 3], output_list)


        # setup/invoke/test sequence
        task4_types = InputTypes("Task4 Types", [int])
        task4_values = InputValues("Task4 Input", [PREVIOUS.task1])
        task4 = Task("Task1", FUNCTION, f_add, task4_types, None)

        task5_types = InputTypes("Task5 Types", [int, int])
        task5_values = InputValues("Task5 Input", [PREVIOUS, PREVIOUS.task2])
        task5 = Task("Task2", FUNCTION, f_add2, task5_types, None)

        task_array_seq = TaskArray("Sequence TaskArray", [task4, task5])
        input_array_seq = InputArray("Sequence InputArray", [task4_values, task5_values])

        output = sequence("Sequence-Split Seq", task_array_seq, input_array_seq)

        self.assertEqual(7, output)


    def test_merge_standalone(self):
        """
            Tests merge only workflow
        """

        # setup Task 1: input types, input values, task
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [1])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, input values, task
        task2_types = InputTypes("Task2 Types", [int])
        task2_values = InputValues("Task2 Input", [2])
        task2 = Task("Task2", FUNCTION, f_add, task2_types, None)

        # setup Task 3: input types, input values, task
        task3_types = InputTypes("Task3Types", [int])
        task3_values = InputValues("Task3 Input", [3])
        task3 = Task("Task3", FUNCTION, f_add, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Merge TaskArray", [task1, task2, task3])
        input_array = InputArray("Merge InputArray", [task1_values, task2_values, task3_values])

        # setup last task
        last_types = InputTypes("Last Task Types", [int])
        last_task_values = InputValues("Last Task Input", [1])
        last_task = Task("Last Task", FUNCTION, f_add, last_types, None)

        output = merge("Merge Standalone", task_array, input_array, last_task, last_task_values)

        self.assertEqual(2, output)

    def test_merge_previous(self):
        """
            Tests merge with PREVIOUS alone
        """
        # setup Task 1: input types, input values, task
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [1])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, input values, task
        task2_types = InputTypes("Task2 Types", [int])
        task2_values = InputValues("Task2 Input", [2])
        task2 = Task("Task2", FUNCTION, f_add, task2_types, None)

        # setup Task 3: input types, input values, task
        task3_types = InputTypes("Task3Types", [int])
        task3_values = InputValues("Task3 Input", [3])
        task3 = Task("Task3", FUNCTION, f_add, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Merge TaskArray", [task1, task2, task3])
        input_array = InputArray("Merge InputArray", [task1_values, task2_values, task3_values])

        # setup last task
        last_types = InputTypes("Last Task Types", [int])
        last_task_values = InputValues("Last Task Input", [PREVIOUS])
        last_task = Task("Last Task", FUNCTION, f_add_l, last_types, None)

        output = merge("Merge Previous", task_array, input_array, last_task, last_task_values)

        self.assertEqual(9, output)

    def test_merge_previous_plus(self):
        """
            Tests merge with PREVIOUS and with other parameters
        """
        # setup Task 1: input types, input values, task
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [1])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, input values, task
        task2_types = InputTypes("Task2 Types", [int])
        task2_values = InputValues("Task2 Input", [2])
        task2 = Task("Task2", FUNCTION, f_add, task2_types, None)

        # setup Task 3: input types, input values, task
        task3_types = InputTypes("Task3Types", [int])
        task3_values = InputValues("Task3 Input", [3])
        task3 = Task("Task3", FUNCTION, f_add, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Merge TaskArray", [task1, task2, task3])
        input_array = InputArray("Merge InputArray", [task1_values, task2_values, task3_values])

        # setup last task
        last_types = InputTypes("Last Task Types", [int])
        last_task_values = InputValues("Last Task Input", [PREVIOUS, [1, 2, 3]])
        last_task = Task("Last Task", FUNCTION, f_add_l, last_types, None)

        output = merge("Merge Previous Plus", task_array, input_array, last_task, last_task_values)

        self.assertEqual(15, output)


    def test_merge_previous_implicit(self):
        """
            Tests merge without PREVIOUS in arguments, but with PREVIOUS logic expected
        """
        # setup Task 1: input types, input values, task
        task1_types = InputTypes("Task1 Types", [int])
        task1_values = InputValues("Task1 Input", [1])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, input values, task
        task2_types = InputTypes("Task2 Types", [int])
        task2_values = InputValues("Task2 Input", [2])
        task2 = Task("Task2", FUNCTION, f_add, task2_types, None)

        # setup Task 3: input types, input values, task
        task3_types = InputTypes("Task3Types", [int])
        task3_values = InputValues("Task3 Input", [3])
        task3 = Task("Task3", FUNCTION, f_add, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Merge TaskArray", [task1, task2, task3])
        input_array = InputArray("Merge InputArray", [task1_values, task2_values, task3_values])

        # setup last task
        last_types = InputTypes("Last Task Types", [int])
        last_task = Task("Last Task", FUNCTION, f_add_l, last_types, None)

        output = merge("Merge Previous Implicit", task_array, input_array, last_task)

        self.assertEqual(9, output)

    def test_merge_single_task(self):
        """
            Tests merge with multiple inputs and single task for parallel part
        """
        # setup task and input types
        task_types = InputTypes("Task Types", [int])
        task = Task("Task", FUNCTION, f_add, task_types, None)

        # setup input values
        task1_values = InputValues("Task1 Input", [1])
        task2_values = InputValues("Task2 Input", [2])
        task3_values = InputValues("Task3 Input", [3])

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Merge TaskArray", [task])
        input_array = InputArray("Merge InputArray", [task1_values, task2_values, task3_values])

        # setup last task
        last_types = InputTypes("Last Task Types", [int])
        last_task_values = InputValues("Last Task Input", [PREVIOUS])
        last_task = Task("Last Task", FUNCTION, f_add_l, last_types, None)
        output = merge("Merge Single Task", task_array, input_array, last_task, last_task_values)

        self.assertEqual(9, output)


    def test_merge_single_input(self):
        """
            Tests merge with single input and multiple tasks for parallel part
        """

        # setup input value
        task_values = InputValues("Task Input", [1])

        # setup Task 1: input types, task
        task1_types = InputTypes("Task1 Types", [int])
        task1 = Task("Task1", FUNCTION, f_add, task1_types, None)

        # setup Task 2: input types, task
        task2_types = InputTypes("Task2 Types", [int])
        task2 = Task("Task2", FUNCTION, f_add, task2_types, None)

        # setup Task 3: input types, task
        task3_types = InputTypes("Task3Types", [int])
        task3 = Task("Task3", FUNCTION, f_add, task3_types, None)

        # Create task and input arrays for Task1, Task2, Task3
        task_array = TaskArray("Merge TaskArray", [task1, task2, task3])
        input_array = InputArray("Merge InputArray", [task_values])

        # setup last task
        last_types = InputTypes("Last Task Types", [int])
        last_task_values = InputValues("Last Task Input", [PREVIOUS])
        last_task = Task("Last Task", FUNCTION, f_add_l, last_types, None)

        output = merge("Merge Single Input", task_array, input_array, last_task, last_task_values)

        self.assertEqual(6, output)


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
