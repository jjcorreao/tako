"""
created on 2013-06-06 by Gilberto Pastorello <gzpastorello@lbl.gov>
"""
import unittest
import time
import mock
from tigres import sequence, InputTypes, InputValues, FUNCTION, Task, InputArray, parallel, TaskArray

from tigres.core.state.program import Program


def stall(sec):
    """Function to test parallel with stop at fail policy.
    If exception is raised before all other tasks finish, then the behavior is correct
    
    :param sec: seconds for task to wait
    :type sec: int
    """
    time.sleep(sec)
    return "OK"


class Test(unittest.TestCase):
    def setUp(self):
        pass

    def tearDown(self):
        "Remove generated log files"
        import os
        import glob

        Program().clear()
        for logfile in glob.glob("t*.log"):
            os.unlink(logfile)



    def test_sequence_parallel_stop(self):
        """Sequence and Parallel fail policies are both stop and both raise exceptions
        
        """

        Program("test_fail_stop_stop", './test_fail.log', prov_graph_filename='/tmp/test_fail.dot')

        def taskError(dummy):
            raise Exception("Task is in Error")

        # Sequence
        mock_task1 = mock.MagicMock()
        mock_task1.execute = taskError
        mock_task2 = mock.MagicMock()
        mock_task2.execute = taskError
        self.assertRaises(Exception, sequence, "my seq", [mock_task1, mock_task2], [[], []])

        # Parallel
        mock_task = mock.MagicMock()
        mock_task.execute = taskError
        task_list = [mock_task]
        input_list = [[], ]
        for i in range(30):
            task_types = InputTypes("Task Types", [int])
            task_inputs = InputValues("Task Input Values", [10])
            task = Task("Task {}".format(i), FUNCTION, stall, task_types, None)
            task_list.append(task)
            input_list.append(task_inputs)

        self.assertRaises(Exception, parallel, "my par", TaskArray('Par Tasks', task_list),
                          InputArray('Par Inputs', input_list))

    # def test_sequence_stop_parallel_continue(self):
    #     """Sequence fail policy is stop and parallel fail policy is continue and both raise exceptions
    #
    #     """
    #
    #     Program("test_fail_stop_continue", '/tmp/test_fail.log', prov_graph_filename='/tmp/test_fail.dot',
    #             fail_sequence=FailPolicy.STOP, fail_parallel=FailPolicy.CONTINUE)
    #
    #     def taskError(dummy):
    #         raise Exception("Task is in Error")
    #
    #     # Sequence
    #     mock_task1 = mock.MagicMock()
    #     mock_task1.execute = taskError
    #     mock_task2 = mock.MagicMock()
    #     mock_task2.execute = taskError
    #     self.assertRaises(Exception, sequence, "my seq", [mock_task1, mock_task2], [[], []])
    #
    #     # Parallel
    #     mock_task3 = mock.MagicMock()
    #     mock_task3.execute = taskError
    #     mock_task4 = mock.MagicMock()
    #     mock_task4.execute = taskError
    #     output_list = parallel("my par", [mock_task3, mock_task4], [[], []])
    #     self.assertIsInstance(output_list[0], TaskFailure)
    #     self.assertIsInstance(output_list[1], TaskFailure)


    # def test_sequence_continue_parallel_stop(self):
    #     ## leaving processes around
    #     """Sequence fail policy is continue and parallel fail policy is stop and both raise exceptions
    #
    #     """
    #
    #     Program("test_fail_stop_continue", '/tmp/test_fail.log', prov_graph_filename='/tmp/test_fail.dot',
    #             fail_sequence=FailPolicy.CONTINUE, fail_parallel=FailPolicy.STOP)
    #
    #     def taskError(dummy):
    #         raise Exception("Task is in Error")
    #
    #     # Sequence
    #     mock_task1 = mock.MagicMock()
    #     mock_task1.execute = taskError
    #     mock_task2 = mock.MagicMock()
    #     mock_task2.execute = taskError
    #     output = sequence("my seq", [mock_task1, mock_task2], [[], []])
    #     self.assertIsInstance(output, TaskFailure)
    #
    #     # Parallel
    #     mock_task = mock.MagicMock()
    #     mock_task.execute = taskError
    #     task_list = [mock_task]
    #     input_list = [[], ]
    #     for i in range(30):
    #         task_types = InputTypes("Task Types", [int])
    #         task_inputs = InputValues("Task Input Values", [10])
    #         task = Task("Task {}".format(i), FUNCTION, stall, task_types, None)
    #         task_list.append(task)
    #         input_list.append(task_inputs)
    #
    #     self.assertRaises(Exception, parallel, "my par", TaskArray('Par Tasks', task_list),
    #                       InputArray('Par Inputs', input_list))


    # def test_sequence_continue_parallel_continue(self):
    #     """Sequence and Parallel fail policies are both continue and both raise exceptions
    #
    #     """
    #
    #     Program("test_fail_stop_continue", '/tmp/test_fail.log', prov_graph_filename='/tmp/test_fail.dot',
    #             fail_sequence=FailPolicy.CONTINUE, fail_parallel=FailPolicy.CONTINUE)
    #
    #     def taskError(dummy):
    #         raise Exception("Task is in Error")
    #
    #     # Sequence
    #     mock_task1 = mock.MagicMock()
    #     mock_task1.execute = taskError
    #     mock_task2 = mock.MagicMock()
    #     mock_task2.execute = taskError
    #     output = sequence("my seq", [mock_task1, mock_task2], [[], []])
    #     self.assertIsInstance(output, TaskFailure)
    #
    #     # Parallel
    #     mock_task3 = mock.MagicMock()
    #     mock_task3.execute = taskError
    #     mock_task4 = mock.MagicMock()
    #     mock_task4.execute = taskError
    #     output_list = parallel("my par", [mock_task3, mock_task4], [[], []])
    #     self.assertIsInstance(output_list[0], TaskFailure)
    #     self.assertIsInstance(output_list[1], TaskFailure)


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
