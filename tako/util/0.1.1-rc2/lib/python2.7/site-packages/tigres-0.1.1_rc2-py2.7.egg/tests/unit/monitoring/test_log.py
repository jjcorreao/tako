"""
Unit tests for monitoring API
"""


try:
    xrange
    range = xrange
except NameError:
    pass
import glob
import os

from tigres import sequence, FUNCTION, TaskArray, InputArray, Task, InputValues, PREVIOUS, query
from tigres.core.monitoring import common, receive, log, start, end
from tigres.core.state.program import Program
from tigres.core.task import TigresObject
from tigres.utils import State


__author__ = 'dang'

import re
import tempfile
import threading
import time
import unittest


class BaseTC(unittest.TestCase):
    def getfile(self):
        with tempfile.NamedTemporaryFile(dir="./", delete=False) as f:
            self._tempf = f
        return self._tempf.name

    def tearDown(self):
        end()
        for logfile in glob.glob('tmp*'):
            os.unlink(logfile)
        for logfile in glob.glob("tigres*.log"):
            os.unlink(logfile)


class TestCase1(BaseTC):
    def test_not_initialized(self):
        """exception if not initialized
        """
        try:
            # need to call next since it's a generator fn
            next(log.query())
        except log.NotInitializedError:
            pass
        self.assertRaises(log.NotInitializedError, log.find, "foo")
        self.assertRaises(log.NotInitializedError, log.check, "any", names=[".*"])



    def test_init(self):
        """init"""
        # bad
        self.assertRaises(ValueError, log.init, (), {})
        # good
        dev_null = os.devnull

        log.init(dev_null, 'a name')
        log.init('file://{}'.format(dev_null), 'another null name')
        log.init('file://{}'.format(dev_null), dev_null, 'tigres.log')

    def test_finalize(self):
        """finalize"""
        log.finalize()

    def test_set_log_level(self):
        """set level"""
        f = self.getfile()
        log.init(f)
        # bad
        self.assertRaises(ValueError, log.set_log_level, (-100000,))
        # good
        log.set_log_level(log.Level.TRACE)
        # cleanup
        log.finalize()

    def test_write(self):
        """write a user-defined log"""
        f = self.getfile()
        log.init(f)
        log.set_log_level(log.Level.DEBUG)
        log.write(log.Level.DEBUG, "hello", message="just saying hi")
        log.write(log.Level.DEBUG, "hello", breakfast="cereal", raisins=10)
        log.write(log.Level.TRACE, "noshow")
        log.write(log.Level.ERROR, "danger-will-robinson")
        log.finalize()

    def test_write_double_quote_value(self):
        """write a user-defined log with double quotes"""
        f = self.getfile()
        log.init(f)
        log.set_log_level(log.Level.DEBUG)
        string_dict = '{"item": "blue", "name": "TestNode", "next": null}'
        log.write(log.Level.DEBUG, "hello", message=string_dict)

        log_records = query(["event = hello"])
        for record in log_records:
            print(record)
            assert "message" in record
            self.assertEqual(record.message, '{"item": "blue", "name": "TestNode", "next": null}')
            break
        log.finalize()

    def test_init_format(self):
        """init with format"""
        # Write with format, check results
        f = None
        for fmt in log.LOG_FORMAT_NL, log.LOG_FORMAT_JSON:
            f = self.getfile()
            log.init(f, 'My Program', format=fmt)
            log.set_log_level(log.Level.INFO)
            log.write(log.Level.INFO, "message", hello="world")
            log.finalize()
            for text in open(f):
                if "hello" not in text:
                    continue
                if fmt == log.LOG_FORMAT_NL:
                    for thing in "ts=", "level=", "hello=world":
                        msg = "format {}: looking for '{}' in '{}'".format(fmt, thing, text)
                        self.failUnless(thing in text, msg)
                elif fmt == log.LOG_FORMAT_JSON:
                    for thing in "\{", "\"ts\s*\":", "\"hello\"\s*:\s*\"world\"":
                        msg = "format {}: looking for regex '{}' in '{}'".format(fmt, thing, text)
                        self.failIf(re.search(thing, text) is None, msg)
                        # Some bad stuff
        self.assertRaises(ValueError, log.init, f, 'foo', format="garbage")
        self.assertRaises(ValueError, log.init, f, 'bar', format=None)


class TestCase2(BaseTC):
    def set_log_format(self):
        log.set_log_format(log.LOG_FORMAT_NL)

    def setUp(self):
        self.set_log_format()
        self.infos = 3
        self.debugs = 4
        self.logfile = self.getfile()
        log.init(self.logfile)
        log.set_log_level(log.Level.DEBUG)
        for i in range(self.infos):
            log.write(log.Level.INFO, "hello", num=i, num_pi=i * 3.1415)
        for i in range(self.debugs):
            log.write(log.Level.DEBUG, "howdy", num=i, num_pi=i * 3.1415, details="say hi to my little friend")

    def tearDown(self):
        end()

        for logfile in glob.glob("tigres*.log"):
            os.unlink(logfile)

        log.finalize()

    def test_find(self):
        """find basic"""
        # empty -> all
        n = len(list(log.find('')))
        self.assertEqual(n, self.infos + self.debugs, "wrong total, {} != {}, in {}"
        .format(n, self.infos + self.debugs, self.logfile))
        # hello == self.infos
        n = len(list(log.find(name='user', states=['hello'])))
        self.assertEqual(n, self.infos, "wrong # hellos, {} != {}, in {}".format(n, self.infos, self.logfile))
        # howdy == self.debugs
        n = len(list(log.find(name='user', states=['howdy'])))
        self.assertEqual(n, self.debugs, "wrong # howdys, {} != {}, in {}".format(n, self.debugs, self.logfile))

    def test_find_kvp(self):
        """find key-value pairs"""
        n = len(list(log.find('', level='INFO')))
        self.assertEqual(n, self.infos, "wrong {} != {}, in {}".
        format(n, self.infos, self.logfile))

    def test_query(self):
        """query"""
        pass


class TestCase2Json(TestCase2):
    """Same as TestCase2 but with JSON logs"""

    def set_log_format(self):
        log.set_log_format(log.LOG_FORMAT_JSON)


def simple_sequence(fn, ntask, narg, seqname="", taskname=""):
    tasks, args = [], []
    for i in range(ntask):
        task_i_name = "{}.{:d}".format(taskname, i)
        tasks.append(Task(task_i_name, FUNCTION, fn, [narg]))
        args.append([object] * narg)
    ta = TaskArray("ta", tasks)
    ia = InputArray("ia", [InputValues("iv", ["x"] * narg) for i in range(ntask)])
    seq = sequence(seqname, ta, ia)
    return seq


def noop(self, *args):
    """Sound and fury, signifying nothing"""
    return


def return1(self, *args):
    """Return a 1"""
    return 1


class TestCaseTasks(BaseTC):
    """Tests for task logging
    """

    def setUp(self):
        f = self.getfile()
        start("TestCaseTasks")

    def tearDown(self):
        end()
        for logfile in glob.glob("tigres*.log"):
            os.unlink(logfile)

    def test_nodetype(self):
        """bad nodetype"""
        self.assertRaises(ValueError, log.check, "fooo", names="something")

    def test_template_status(self):
        """Status from a template"""
        sname, tname = "tigres.log", "footask"
        simple_sequence(noop, 5, 2, seqname=sname, taskname=tname)
        statii = log.check("template", names=sname)
        self.assertEqual(len(statii), 1)
        self.assertEqual(statii[0].state, State.DONE)

    def test_task_status(self):
        """Status from a task"""
        ntask, sname, tname = 5, "foo", "footask"
        simple_sequence(noop, ntask, 2, seqname=sname, taskname=tname)
        statii = log.check(log.NodeType.TASK, names=tname)
        self.assertEqual(len(statii), 5)
        for i in range(ntask):
            print((statii[i].state))
            self.assertEqual(statii[i].state, State.DONE)

    def test_task_inout(self):
        "Input/output objects logged from a task"
        # Create a 2-task sequence where one object
        task1 = Task("task1", FUNCTION, return1)
        task2 = Task("task2", FUNCTION, noop)
        taskarr = TaskArray("task-list", [task1, task2])
        infile, fon = open(os.devnull, mode="r"), "supergrover"
        inlist = [100, 200, 300]
        in1 = InputValues("task1-in", [TigresObject(infile, name=fon, path=infile.name),
                                       TigresObject(inlist)])
        in2 = InputValues("task2-in", [PREVIOUS])
        inarr = InputArray("task-inputs", [in1, in2])
        sequence("my-sequence", taskarr, inarr)
        # get task RUN message
        run_info = log.find("task1", event=State.RUN)
        self.assertEqual(len(run_info), 1)
        rec = run_info[0]
        # Check that OID is present for the wrapped objects
        #print("@@rec="+str(rec))
        for objname in fon, "2":
            #input_oid_key = "{}_{}_oid".format(shared.Keyword.INPUT, objname)
            self.assertTrue("tg_task_id" in rec)


class TestCaseSocketLogger(BaseTC):
    def setUp(self):
        log.set_log_format(log.LOG_FORMAT_NL)
        self.started = False

    def server_start(self):
        self.server = receive.TCPServer()
        self.sthr = threading.Thread(target=self.server_loop, args=[])
        self.sthr.start()
        self.started = True

    def tearDown(self):
        end()
        for logfile in glob.glob("tigres*.log"):
            os.unlink(logfile)

        if self.started:
            self.server.handle_close()
            self.sthr.join(5)

    def server_loop(self):
        self.server.run()

    def test_noserver(self):
        """Invocation without a server to connect to"""
        self.assertRaises(receive.ConnectionError, log.SocketLogger, ())
        self.assertRaises(ValueError, log.SocketLogger, port='x')

    def test_open(self):
        """Connect to server"""
        self.server_start()
        logger = log.SocketLogger()

    def test_init(self):
        """Creating socket logger from init"""
        self.server_start()
        log.init("tcp://localhost")
        self.assertRaises(receive.ConnectionError,
                          log.init, "tcp://localhost:12345")

    def test_msg(self):
        """Send/receive a few msgs"""
        self.server_start()
        dr = DataRcv()
        self.server.attach(dr, datatype=str)
        logger = log.SocketLogger()
        for lvl in common.Level.INFO, common.Level.ERROR:
            dr.rec=[]
            logger.set_level(lvl)
            for i in range(0, 10):
                # FIXME: If this time isn't here this causes
                # nose.proxy.ConnectionResetError: [Errno 104] Connection reset by peer
                # during nosetests.
                try:
                    logger.log(lvl, "hello", {"grass": "green", "day": i})
                except Exception as e:
                    print(e)

            time.sleep(1)
            for j, rec in enumerate(dr.rec):
                self.assertGreaterEqual(rec.find('grass'), 0)
                self.assertGreaterEqual(rec.find('green'), 0)
                self.assertGreaterEqual(rec.find('day'), 0)
                # .. TODO:: this will break if we switch to JSON
                p = rec.find('day={:d}'.format(j))
                self.assertGreaterEqual(p, 0, "day={:d} not found in: {}"
                    .format(j, rec))
                p = rec.find('ts=')
                self.assertGreaterEqual(p, 0, "missing timestamp in: {}"
                    .format(rec))
                level_name = common.Level.to_name(lvl)
                p = rec.find('level={}'.format(level_name))
                self.assertGreaterEqual(p, 0, "level={} not found in: {}"
                    .format(level_name, rec))



class DataRcv(receive.Observer):
    def __init__(self):
        self.rec = []

    def update(self, data):
        self.rec.append(data)


class TestCaseJson(BaseTC):
    def setUp(self):
        log.set_log_format('json')

    def test_set(self):
        """Set log format"""
        log.init(os.devnull)
        log.set_log_format('json')
        self.assertRaises(ValueError, log.set_log_format, 'foo')
        self.assertRaises(ValueError, log.set_log_format, None)

    def test_get(self):
        """Get log format"""
        log.init(os.devnull)
        for val in 'nl', 'json':
            log.set_log_format(val)
            self.assertEquals(log.get_log_format(), val)

    def test_write(self):
        """Write a message, see if it's JSON"""
        f = self.getfile()
        log.init(f)
        name = "test1"
        data = {"pipeline": "Hawaii", "mavericks": "California"}
        log.write(common.Level.INFO, "test1", **data)
        text = open(f).read()
        #print(text)

    def tearDown(self):
        end()
        for logfile in glob.glob("tigres*.log"):
            os.unlink(logfile)

        log.finalize()
        log.set_log_format('nl')


class TestCaseInits(BaseTC):
    def _find_program_name(self, f, program_name):
        import json

        for line in open(f):
            if not line.startswith(common.META_LINE_MARKER):
                obj = json.loads(line.strip())
                wf_key = common.Keyword.PROGRAM_NAME
                self.failUnless(wf_key in obj, "Missing field {}".format(wf_key))
                self.failUnless(obj[wf_key] == program_name,
                                "Field {} = '{}' but expected '{}'"
                                .format(wf_key, obj[wf_key], program_name))

    def tearDown(self):
        end()
        for logfile in glob.glob("tigres*.log"):
            os.unlink(logfile)

        BaseTC.tearDown(self)
        Program().clear()

    def test_write_program_name(self):
        """Look for matching workflow name from a write"""
        program_name = "my workflow"
        f = self.getfile()
        Program(program_name, log_dest=f, log_format=common.LOG_FORMAT_JSON)
        log.write(common.Level.INFO, "test1")
        self._find_program_name(f, program_name)

    def test_write_template(self):
        """Look for matching workflow name from a template"""
        program_name = "my workflow"
        f = self.getfile()
        Program(program_name, log_dest=f, log_format=common.LOG_FORMAT_JSON)
        print((Program().name))
        simple_sequence(noop, 1, 1, seqname="my sequence", taskname="my task")
        self._find_program_name(f, program_name)


if __name__ == '__main__':
    unittest.main()
