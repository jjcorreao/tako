import sys
from tigres import *

# Initial inputs to the workflow
from tigres.utils import Execution


input1_task1 = ['cat', 'dog', 'parrot']


# Following functions are given 
def task1impl(text):
    return text


def task2impl(text):
    return text[::-1]


def main(execution):
    # This example tests reuse of arrays across different workflows
    start(name="example_workflow_function_loop", log_dest='example_workflow_function_loop.log',
          execution=execution)

    for i in input1_task1:
        # Define input types for Task1
        task1_types = InputTypes("Task1types", [str])
        # Define Task 1
        task1 = Task("Task1", FUNCTION, task1impl, task1_types, None)
        # Assign inputs for task1
        task1_values = InputValues("Input Task1", [i])

        # Similarly, define input types and task for task2
        task2_types = InputTypes("Task2types", [str])
        task2 = Task("Task2", FUNCTION, task2impl, task2_types, None)
        # Assign values for task2 data.
        # Use "PREVIOUS to mention that task2s second input comes from task1.
        # PREVIOUS by default picks the first output of
        # the previous task in the set.
        # For other specific outputs, the notation
        # 'PREVIOUS.<taskName>.<outputNum>' must be used.
        task2_values = InputValues("Input Task2", [PREVIOUS])

        # Create a task array containing task1 and task2
        task_array12 = TaskArray("sequence tasks12", [task1, task2])
        # Create a data array with task1 and task2's input values
        input_array12 = InputArray("sequence data12", [task1_values, task2_values])

        # Invoke the template
        output_seq = sequence("my seq", task_array12, input_array12)

        print(("Input ", i, " Output ", output_seq))

    dot_execution()


if __name__ == "__main__":

    if len(sys.argv) <= 1:
        print(("Usage: {} ({})>".format(sys.argv[0], "|".join(list(Execution.LOOKUP.keys())))))
        exit()

    main(Execution.get(sys.argv[1]))






