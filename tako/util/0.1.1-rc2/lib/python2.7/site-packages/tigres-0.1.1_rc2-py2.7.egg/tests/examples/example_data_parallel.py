#!/usr/bin/env python
"""
Data parallel example
"""

import os
import sys
from tigres import *
from tigres.utils import Execution, TaskFailure


def median(numericValues):
    theValues = sorted(numericValues)
    if len(theValues) % 2 == 1:
        return theValues[int((len(theValues) + 1) / 2 - 1)]
    else:
        lower = theValues[int(len(theValues) / 2 - 1)]
        upper = theValues[int(len(theValues) / 2)]
        return (float(lower + upper)) / 2


def file_col_generator(myfile, col):
    for line in myfile:
        line_split = line.split(',')
        value = float(line_split[col])
        yield value


def averageByColumn(filename, column_num):
    with open(filename, 'rU') as myfile:
        values = []
        for value in file_col_generator(myfile, column_num):
            values.append(value)
        total = sum(values)
        count = len(values)
        average = total / count
        return (averageByColumn.__name__, column_num, average)


def totalByColumn(filename, column_num):
    with open(filename, 'rU') as myfile:
        values = []
        for value in file_col_generator(myfile, column_num):
            values.append(value)
        total = sum(values)
        return (totalByColumn.__name__, column_num, total)


def medianByColumn(filename, column_num):
    with open(filename, 'rU') as myfile:
        values = []
        for value in file_col_generator(myfile, column_num):
            values.append(value)

        return (medianByColumn.__name__, column_num, median(values))


def main(execution):
    start(log_dest=os.path.splitext(__file__)[0] + '.log', execution=execution)
    # Inputs
    input_cols = [2, 4, 6, 7, 8]
    impls = [averageByColumn, totalByColumn, medianByColumn]


    # Define all of the Tasks
    tasks = []
    inputs = []
    for col in input_cols:
        for impl in impls:
            inputs.append(InputValues('values', ["{}/data.csv".format(os.getcwd()), col]))
            tasks.append(Task("Task.%s.%s" % (col, impl.__name__), task_type=FUNCTION, impl_name=impl))

    sometask = "Task.{}.{}".format(input_cols[0], impls[0].__name__)
    status = check('task', names=sometask)
    if status:
        print((".. Pre-template state of {} = {}".format(sometask, status[0].state)))

    # Invoke the template
    output_par = parallel(None, tasks, InputArray('foo', inputs))

    state = check('task', names=sometask)
    if state:
        print((".. State of {} = {}".format(sometask, state[0].state)))

    print(("Parallel Output Result Count", len(output_par)))
    for output in output_par:
        if isinstance(output, TaskFailure):
            print((output.error))
        else:
            print(output)


if __name__ == "__main__":

    if len(sys.argv) <= 1:
        print(("Usage: {} ({})>".format(sys.argv[0], "|".join(list(Execution.LOOKUP.keys())))))
        exit()
    main(Execution.get(sys.argv[1]))